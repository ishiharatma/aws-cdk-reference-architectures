# S3-Basics -- S3 Bucket Basics

*Read this in other languages:* [![üáØüáµ Êó•Êú¨Ë™û](https://img.shields.io/badge/%F0%9F%87%AF%F0%9F%87%B5-Êó•Êú¨Ë™û-white)](./README.ja.md) [![üá∫üá∏ English](https://img.shields.io/badge/%F0%9F%87%BA%F0%9F%87%B8-English-white)](./README.md)

![Level](https://img.shields.io/badge/Level-100-blue?style=flat-square)
![Services](https://img.shields.io/badge/Services-S3-orange?style=flat-square)

## Introduction

In this architecture, you can learn the following:

- How minimal CDK code translates to CloudFormation templates
- Default behavior of L2 Constructs and how to customize them
- Best practices for S3 bucket security configuration
- Cost optimization through lifecycle rules
- Version management and non-current version handling

## Architecture Overview

An overview of the S3 bucket we will create:

![Architecture Overview](https://raw.githubusercontent.com/ishiharatma/aws-cdk-reference-architectures/main/s3/s3-basics/overview.png)

We will implement 8 patterns:

1. CDKDefault: Completely default settings
2. Named: With explicit bucket name
3. AutoDeleteObjects: Auto-delete objects on bucket deletion
4. BlockPublicAccessOff: Partial public access settings disabled
5. EncryptionSSEKMSManaged: Encryption with AWS-managed KMS key
6. EncryptionSSEKMSCustomer: Encryption with customer-managed KMS key
7. LifecycleRules: Cost optimization through lifecycle rules
8. VersioningEnabled: Versioning and lifecycle management

## Prerequisites

To proceed with this exercise, you need:

- AWS CLI v2 installed and configured
- Node.js 20 or later
- AWS CDK CLI (`npm install -g aws-cdk`)
- Basic knowledge of TypeScript
- AWS Account (can be executed with Free Tier)

## Project Directory Structure

The project structure for this exercise is:

```text
s3-basics/
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ s3-basics.ts               # Application entry point
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ stacks/
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ s3-basics-stack.ts         # Stack definition
‚îÇ   ‚îî‚îÄ‚îÄ stages/
‚îÇ          ‚îî‚îÄ‚îÄ s3-basics-stage.ts         # Stage definition
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îú‚îÄ‚îÄ compliance
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ cdk-nag.test.ts     # Test code (explained in later exercises)
‚îÇ   ‚îú‚îÄ‚îÄ snapshot
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ snapshot.test.ts    # Test code (explained in later exercises)
‚îÇ   ‚îî‚îÄ‚îÄ unit
‚îÇ          ‚îî‚îÄ‚îÄ s3-basics.test.ts   # Test code (explained in later exercises)
‚îú‚îÄ‚îÄ cdk.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

## Pattern 1: Understanding CDK Default Settings

Let's start with the simplest implementation:

```typescript
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as s3 from 'aws-cdk-lib/aws-s3';

export class S3BasicStack extends cdk.Stack {
  public readonly bucket: s3.IBucket;

  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // S3 bucket with completely default settings
    this.bucket = new s3.Bucket(this, 'CDKDefault', {});
  }
}
```

With just this code, an S3 bucket is created. Let's see what CloudFormation template this code actually generates.

Generated CloudFormation:

When you run `cdk synth`, the following CloudFormation template is generated:

```json
{
  "Resources": {
    "CDKDefaultE8B73DAC": {
      "Type": "AWS::S3::Bucket",
      "UpdateReplacePolicy": "Retain",
      "DeletionPolicy": "Retain",
      "Metadata": {
        "aws:cdk:path": "Dev/SandboxS3Basic/CDKDefault/Resource"
      }
    }
  }
}
```

### Details of Default Settings

Let's examine the settings that CDK automatically configures.

#### 1. Logical ID Generation

The Construct ID `CDKDefault` is appended with a hash value `E8B73DAC` to become `CDKDefaultE8B73DAC`. This hash value is auto-generated to ensure uniqueness within the stack.

#### 2. UpdateReplacePolicy and DeletionPolicy

Both are set to `Retain`. This is a safe setting where the S3 bucket remains even if the stack is deleted.

AWS Documentation > [UpdateReplacePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-attribute-updatereplacepolicy.html) and [DeletionPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-attribute-deletionpolicy.html)

‚ö†Ô∏è: If you deploy this code to AWS and delete it, you will need to manually delete the `CDKDefault` bucket.

#### 3. Implicitly Set Items

Although not explicitly shown in the CloudFormation template, the following settings are applied:

- Encryption: SSE-S3 (Amazon S3 managed encryption key)
- Public Access: Fully blocked (recommended setting)
- Versioning: Disabled
- Bucket Name: Auto-generated by AWS

These are applied as AWS default values. CDK defaults to secure configurations, so even without explicit specification, you get a safe setup.

## Pattern 2: Specifying Bucket Name

In this example, the bucket name is explicitly specified:

However, in actual projects, we recommend NOT specifying bucket names. This is also recommended in [AWS documentation](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_s3.Bucket.html#bucketname) to let CloudFormation auto-generate names.

Reasons for recommending auto-generation:

- New bucket cannot be created during resource replacement
  - During replacement, new resource is created before the old one is deleted, so creation fails with the same name
- Names auto-generated by CDK are sufficiently unique
- Improved deployment flexibility

We recommend specifying bucket names only when absolutely necessary.

```typescript
const accountId = cdk.Stack.of(this).account;
const region = cdk.Stack.of(this).region;
const regionNoHyphens = region.replace(/-/g, '');

const bucketName = [
  props.project,       // Project name
  props.environment,   // Environment identifier
  'namedbucket',       // Purpose
  accountId,           // AWS account ID
  regionNoHyphens      // Region (hyphens removed)
].join('-').toLowerCase();
new s3.Bucket(this, 'NamedBucket', {
  bucketName,
  autoDeleteObjects: props.isAutoDeleteObject,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});
// Result example: myproject-dev-logs-123456789012-apnortheast1
```

Main bucket naming rules:

- Must be globally unique
- Only lowercase letters, numbers, periods (`.`), and hyphens (`-`)
- 3-63 characters

See [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html#general-purpose-bucket-names) for detailed rules.

## Pattern 3: Delete Behavior Control

In development environments, you may want to delete the bucket and its objects together when the stack is deleted.

```typescript
new s3.Bucket(this, 'AutoDeleteObjects', {
  autoDeleteObjects: true,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});
```

Generated CloudFormation:

With this setting, the following is added to the CloudFormation template:

1. S3 Bucket: Changes `DeletionPolicy` to `Delete`
2. Bucket Policy: Permissions for custom resource
3. Custom Resource: Lambda function to execute object deletion
4. IAM Role: Role for Lambda execution

```json
{
  "AutoDeleteObjects9931B84E": {
    "Type": "AWS::S3::Bucket",
    "Properties": {
      "Tags": [
        {
          "Key": "aws-cdk:auto-delete-objects",
          "Value": "true"
        }
      ]
    },
    "UpdateReplacePolicy": "Delete",
    "DeletionPolicy": "Delete"
  },
  "AutoDeleteObjectsPolicy6BD2BF78": {
    "Type": "AWS::S3::BucketPolicy"
  },
  "AutoDeleteObjectsAutoDeleteObjectsCustomResourceF9A68CC5": {
    "Type": "Custom::S3AutoDeleteObjects"
  },
  "CustomS3AutoDeleteObjectsCustomResourceProviderRole3B1BD092": {
    "Type": "AWS::IAM::Role"
  },
  "CustomS3AutoDeleteObjectsCustomResourceProviderHandler9D90184F": {
    "Type": "AWS::Lambda::Function",
    "Properties": {
      "Runtime": "nodejs22.x",
      "Timeout": 900
    }
  }
}
```

### Important Note

Use `autoDeleteObjects: true` with caution in production environments:

- Increased risk of accidental data deletion
- Important data such as audit logs may be lost

Recommend using this setting only in development/test environments and explicitly set `removalPolicy: cdk.RemovalPolicy.RETAIN` in production to prioritize data protection.

## Pattern 4: Public Access Control

S3 bucket public access settings are critical for security. By default, public access blocks are enabled, but this configuration disables them.

CDK Code:

```typescript
// Allow public policy only (block everything else)
new s3.Bucket(this, 'BlockPublicAccessOff', {
  blockPublicAccess: new s3.BlockPublicAccess({ 
    blockPublicPolicy: false 
  }),
  autoDeleteObjects: true,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});
```

Generated CloudFormation:

```json
{
  "BlockPublicAccessOff9C2A29A0": {
    "Type": "AWS::S3::Bucket",
    "Properties": {
      "PublicAccessBlockConfiguration": {
        "BlockPublicAcls": true,
        "BlockPublicPolicy": false,
        "IgnorePublicAcls": true,
        "RestrictPublicBuckets": true
      }
    }
  }
}
```

### Four Public Access Block Settings

| Setting | Default | Description |
|---------|---------|-------------|
| BlockPublicAcls | true | Reject public ACL settings |
| BlockPublicPolicy | true | Reject public bucket policies |
| IgnorePublicAcls | true | Ignore public ACLs |
| RestrictPublicBuckets | true | Restrict publicly accessible buckets |

### Best Practices

Normally, all settings should be kept `true` (complete block). If public access is needed, consider:

1. Use CloudFront: Keep S3 private, deliver through CloudFront
2. Signed URLs: Grant temporary access permissions
3. Strict bucket policy control: IP address restrictions, etc.

## Pattern 5: Encryption Settings

S3 has three encryption methods:

### 1. SSE-S3 (Default)

```typescript
// When explicitly specifying
new s3.Bucket(this, 'EncryptionSSES3', {
  encryption: s3.BucketEncryption.S3_MANAGED,
});
```

- AWS-managed encryption keys
- No additional cost
- Key rotation automatically performed by AWS

### 2. SSE-KMS (AWS Managed Key)

```typescript
new s3.Bucket(this, 'EncryptionSSEKMSManaged', {
  encryption: s3.BucketEncryption.KMS_MANAGED,
  autoDeleteObjects: true,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});
```

Generated CloudFormation:

```json
{
  "EncryptionSSEKMSManagedBEDBF190": {
    "Type": "AWS::S3::Bucket",
    "Properties": {
      "BucketEncryption": {
        "ServerSideEncryptionConfiguration": [
          {
            "ServerSideEncryptionByDefault": {
              "SSEAlgorithm": "aws:kms"
            }
          }
        ]
      }
    }
  }
}
```

- Uses AWS-managed KMS keys
- Key usage auditable through CloudTrail
- Charged for KMS API calls

### 3. SSE-KMS (Customer Managed Key)

```typescript
new s3.Bucket(this, 'EncryptionSSEKMSCustomer', {
  encryption: s3.BucketEncryption.KMS,
  encryptionKey: new cdk.aws_kms.Key(this, 'CustomKmsKey', {
    enableKeyRotation: true,
  }),
  autoDeleteObjects: true,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});
```

- Full control over key management
- Can configure key rotation
- Fine-grained access control

## Pattern 6: Lifecycle Rules

Lifecycle rules are a key cost optimization tool.

CDK Code:

```typescript
const lifecycleBucket = new s3.Bucket(this, 'LifecycleRules', {
  lifecycleRules: [
    {
      id: 'MoveToIAAfter30Days',
      enabled: true,
      transitions: [
        {
          storageClass: s3.StorageClass.INFREQUENT_ACCESS,
          transitionAfter: cdk.Duration.days(30),
        },
      ],
    },
  ],
  autoDeleteObjects: true,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});

// Method to add rules after creation
lifecycleBucket.addLifecycleRule({
  id: 'MoveToGlacierAfter90Days',
  enabled: true,
  transitions: [
    {
      storageClass: s3.StorageClass.GLACIER,
      transitionAfter: cdk.Duration.days(90),
    },
  ],
});

lifecycleBucket.addLifecycleRule({
  id: 'ExpireAfter365Days',
  enabled: true,
  expiration: cdk.Duration.days(365),
});
```

Generated CloudFormation:

```json
{
  "LifecycleRules2799D541": {
    "Type": "AWS::S3::Bucket",
    "Properties": {
      "LifecycleConfiguration": {
        "Rules": [
          {
            "Id": "MoveToIAAfter30Days",
            "Status": "Enabled",
            "Transitions": [
              {
                "StorageClass": "STANDARD_IA",
                "TransitionInDays": 30
              }
            ]
          },
          {
            "Id": "MoveToGlacierAfter90Days",
            "Status": "Enabled",
            "Transitions": [
              {
                "StorageClass": "GLACIER",
                "TransitionInDays": 90
              }
            ]
          },
          {
            "ExpirationInDays": 365,
            "Id": "ExpireAfter365Days",
            "Status": "Enabled"
          }
        ]
      }
    }
  }
}
```

### Storage Class Selection

| Storage Class | Use Case | Cost |
|---------------|----------|------|
| Standard | Frequent access | High |
| Standard IA | After 30 days (monthly access) | Medium |
| Glacier Instant Retrieval | After 90 days (annual access) | Low |
| Glacier Flexible Retrieval | Archive (After 90 days (annual access) ) | Low |
| Glacier Deep Archive | Archive (minimal access) | Lowest |

### Cost Optimization Tips

1. Analyze access patterns: Use S3 Storage Lens or access logs
2. Staged transition: STANDARD ‚Üí STANDARD_IA ‚Üí GLACIER INSTANT RETRIEVAL
3. Set expiration: Auto-delete unnecessary data

## Pattern 7: Comprehensive Lifecycle Management with Versioning

Finally, an example with versioning enabled:

CDK Code:

```typescript
new s3.Bucket(this, 'VersioningEnabled', {
  versioned: true,
  autoDeleteObjects: true,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
  lifecycleRules: [
    {
      id: 'ExpireNonCurrentVersionsAfter90Days',
      enabled: true,
      noncurrentVersionExpiration: cdk.Duration.days(90),
      noncurrentVersionsToRetain: 3,
    },
    {
      id: 'NonCurrentVersionTransitionToIAAfter30Days',
      enabled: true,
      noncurrentVersionTransitions: [
        {
          storageClass: s3.StorageClass.INFREQUENT_ACCESS,
          transitionAfter: cdk.Duration.days(30),
        },
      ],
    },
    {
      id: 'CurrentVersionTransitionToIAAfter60Days',
      enabled: true,
      transitions: [
        {
          storageClass: s3.StorageClass.INFREQUENT_ACCESS,
          transitionAfter: cdk.Duration.days(60),
        },
      ],
    },
    {
      id: 'CurrentVersionTransitionToGlacierAfter90Days',
      enabled: true,
      transitions: [
        {
          storageClass: s3.StorageClass.GLACIER,
          transitionAfter: cdk.Duration.days(90),
        },
      ],
    },
    {
      id: 'ExpireCurrentVersionsAfter365Days',
      enabled: true,
      expiration: cdk.Duration.days(365),
    },
    {
      id: 'AbortIncompleteMultipartUploadsAfter7Days',
      enabled: true,
      abortIncompleteMultipartUploadAfter: cdk.Duration.days(7),
    }
  ],
});
```

### What is Versioning?

When you enable [versioning](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Versioning.html), all change history of objects is saved:

- Current version: Latest state
- Non-current versions: Past states

Generated CloudFormation:

```json
{
  "VersioningEnabledC271D012": {
    "Type": "AWS::S3::Bucket",
    "Properties": {
      "VersioningConfiguration": {
        "Status": "Enabled"
      },
      "LifecycleConfiguration": {
        "Rules": [
          {
            "Id": "ExpireNonCurrentVersionsAfter90Days",
            "NoncurrentVersionExpiration": {
              "NewerNoncurrentVersions": 3,
              "NoncurrentDays": 90
            },
            "Status": "Enabled"
          }
        ]
      }
    }
  }
}
```

### Lifecycle Rule Details

#### 1. Non-current Version Expiration

```typescript
noncurrentVersionExpiration: cdk.Duration.days(90),
noncurrentVersionsToRetain: 3,
```

- Delete non-current versions after 90 days
- However, keep the latest 3

#### 2. Non-current Version Transition

```typescript
noncurrentVersionTransitions: [
  {
    storageClass: s3.StorageClass.INFREQUENT_ACCESS,
    transitionAfter: cdk.Duration.days(30),
  },
]
```

- Transition non-current versions to STANDARD_IA after 30 days

#### 3. Current Version Transition

```typescript
transitions: [
  {
    storageClass: s3.StorageClass.INFREQUENT_ACCESS,
    transitionAfter: cdk.Duration.days(60),
  },
  {
    storageClass: s3.StorageClass.GLACIER,
    transitionAfter: cdk.Duration.days(90),
  },
]
```

- Transition to STANDARD_IA after 60 days
- Transition to GLACIER after 90 days

#### 4. Incomplete Multipart Upload Cleanup

```typescript
abortIncompleteMultipartUploadAfter: cdk.Duration.days(7),
```

If a multipart upload is interrupted, it's automatically deleted after 7 days. This helps reduce unnecessary storage costs.

## Deploy and Verification

### Deploy

```bash
# Check differences
cdk diff --project=sample --env=dev

# Deploy
cdk deploy "**" --project=sample --env=dev
```

### Verification Methods

1. AWS Management Console
   - Verify created buckets in S3 console
   - Check encryption settings in Properties tab
   - Review lifecycle rules in Management tab

2. AWS CLI

```bash
# List buckets
aws s3 ls

# Check bucket versioning configuration
aws s3api get-bucket-versioning --bucket <bucket-name>

# Check lifecycle configuration
aws s3api get-bucket-lifecycle-configuration --bucket <bucket-name>

# Check encryption configuration
aws s3api get-bucket-encryption --bucket <bucket-name>
```

### Cleanup

```bash
# Delete stack
cdk destroy "**" --project=sample --env=dev

# Skip confirmation prompt
cdk destroy "**" --force --project=sample --env=dev
```

## Best Practices

### Security

1. Complete public access block: Keep default unless special reason
2. Encryption is mandatory: At minimum SSE-S3, recommended SSE-KMS
3. Enable versioning: For data protection and compliance requirements
4. Enable access logging: For security audits and troubleshooting

### Cost Optimization

1. Configure lifecycle rules: Choose storage class based on access patterns
2. Delete incomplete uploads: Auto-delete after ~7 days
3. Manage non-current versions: Retain only necessary versions
4. Consider S3 Intelligent-Tiering: When access patterns are unclear

### Operations

1. Bucket naming convention: Include project name, environment, and purpose
2. Tagging: Essential for cost allocation and resource management
3. CloudTrail integration: Audit API calls
4. CloudWatch metrics: Monitor bucket size and request count

## Summary

This architecture demonstrates the basics of S3 bucket implementation with AWS CDK.

### What You Learned

1. CDK default settings: Secure configuration with minimal code
2. CloudFormation correspondence: How CDK code translates to templates
3. Delete behavior control: When to use `autoDeleteObjects` and `removalPolicy`
4. Three encryption methods: SSE-S3, SSE-KMS (AWS-managed), SSE-KMS (customer-managed)
5. Lifecycle rules: Staged transitions for cost optimization
6. Versioning: Comprehensive management of current and non-current versions

## References

- [AWS CDK Official Documentation](https://docs.aws.amazon.com/cdk/v2/guide/home.html)
- [S3 Bucket Security Best Practices](https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html)
- [S3 Lifecycle Configuration](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html)
- [GitHub Repository](https://github.com/ishiharatma/aws-cdk-reference-architectures)
